This is the **L7 frontline**. If this code is buggy, your latency spikes and your "100% uptime" dream dies. We aren't testing RegEx in a sandbox; we're testing **Hyper 1.0 throughput, SNI handshakes, and actual reverse-proxying** to local backends.

### ðŸ›  VPS Setup (Edge Pre-flight)
```bash
# 1. Install OpenSSL for generating test certs
sudo apt install -y openssl curl

# 2. Allow binding to low ports (80/443) for real-world testing
sudo setcap 'cap_net_bind_service=+ep' target/debug/shellwego-edge
```

---

### 1. Unit Tests (Routing & Matching)
*Target: `src/router.rs`, `src/proxy.rs`*
*Goal: Prove the routing engine isn't a bottleneck.*

*   **TC-EDGE-U1: Domain Wildcard Resolution**
    *   Input: Rule `*.sovereign.cloud`. Incoming Host: `my-app.sovereign.cloud`.
    *   Verify: Matcher returns `Ok(RouteId)`. Test negative case with `other.cloud`.
*   **TC-EDGE-U2: Header Transformation Logic**
    *   Action: Apply middleware to add `X-Forwarded-For` and strip `Cookie`.
    *   Verify: The internal `Request` object has sanitized headers before reaching the proxy logic.
*   **TC-EDGE-U3: Path Prefix Stripping**
    *   Input: Path `/api/v1/users`, Rule: Strip `/api/v1`.
    *   Verify: Outgoing URI is `/users`.

---

### 2. Integration Tests (The TLS & Proxy Loop)
*Target: `src/tls.rs`, `src/proxy.rs`*
*Goal: Real sockets, real handshakes.*

*   **TC-EDGE-I1: Hot-Reload Config**
    *   Action: Start Edge with 0 routes. Update config file/NATS to add Route A.
    *   Verify: Edge accepts traffic for Route A within <100ms without restarting the process.
*   **TC-EDGE-I2: Dynamic SNI Selection**
    *   Action: Generate self-signed certs for `site-a.com` and `site-b.com`.
    *   Verify: `rustls` SNI callback picks the correct certificate based on the client handshake.
*   **TC-EDGE-I3: Reverse Proxy to Axum Backend**
    *   Setup: Start a dummy Axum server on `127.0.0.1:8081`. Point Edge to it.
    *   Action: `curl -v http://localhost:80/path`
    *   Verify: Backend receives the request; Edge returns `200 OK`.

---

### 3. E2E Tests (Production Stress Test)
*Target: `src/lib.rs`*
*Goal: Proving itâ€™s a Traefik killer.*

*   **TC-EDGE-E2E-1: The WebSocket Upgrade Tunnel**
    1.  **Backend:** Start a real WebSocket echo server.
    2.  **Proxy:** Route `/ws` to that backend.
    3.  **Client:** Initiate a real `tokio-tungstenite` connection through Edge.
    4.  **Verify:** Full bidirectional message flow. No dropped frames.
*   **TC-EDGE-E2E-2: Auto-ACME Flow (Self-Hosted CA)**
    1.  **Setup:** Run [Pebble](https://github.com/letsencrypt/pebble) (small ACME test server).
    2.  **Action:** Request a route with `auto_tls: true`.
    3.  **Verify:** Edge completes the HTTP-01 challenge, fetches a cert from Pebble, and starts serving HTTPS on 443 automatically.
*   **TC-EDGE-E2E-3: Distributed Rate Limiting (Hard Mode)**
    1.  **Setup:** Configure 10 req/sec limit on a route.
    2.  **Action:** Blast the route with `wrk` or `hey` at 100 req/sec.
    3.  **Verify:** Exactly 10 requests pass; others get `429` with `Retry-After` headers.
*   **TC-EDGE-E2E-4: Gzip/Brotli Compression**
    1.  **Action:** Request a large JSON payload with `Accept-Encoding: gzip`.
    2.  **Verify:** Content-Encoding is `gzip`; binary size is reduced.

---

### ðŸš€ How to Run
```makefile
test-edge-real:
	# Requires sudo for some ACME/Port-bind tests
	sudo cargo test -p shellwego-edge -- --test-threads=1
```

**Production Proof:** If this passes, you have a **zero-copy L7 proxy** that handles TLS termination and dynamic routing better than Go-based alternatives. You're now running at **Rust speed**. AWS CloudFront is just an expensive wrapper.