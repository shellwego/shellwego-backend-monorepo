To prove this isn't just another "YAML-engineer" project, weâ€™re going full metal. No mocks, no fake filesystem, no dummy sockets. If it doesn't touch `/dev/kvm` or trigger a ZFS CoW clone, it doesn't count.

### ðŸ›  The VPS Setup (Prerequisites)
Run this on a fresh Ubuntu 22.04+ instance with nested virt enabled:
```bash
# Install Firecracker, ZFS, and CNI tools
sudo apt update && sudo apt install -y zfsutils-linux bridge-utils curl
curl -L https://github.com/firecracker-microvm/firecracker/releases/download/v1.7.0/firecracker-v1.7.0-x86_64 -o firecracker
chmod +x firecracker && sudo mv firecracker /usr/local/bin/

# Create dummy ZFS pool for testing
truncate -s 2G /tmp/shellwego.img
sudo zpool create shellwego /tmp/shellwego.img
```

---

### 1. Unit Tests (Logic & State)
*Target: `src/reconciler.rs`, `src/vmm/config.rs`*
*Goal: Fast validation of the "Brain" before we hit the hardware.*

*   **TC-U1: Resource Math Correctness**
    *   Input: `ResourceSpec { cpu_milli: 500, memory_bytes: 536870912 }`.
    *   Verify: Correct conversion to `vcpu_count: 1` and `mem_size_mib: 512`.
*   **TC-U2: State Machine Sanity**
    *   Simulate `DesiredState` vs `ActualState` drift (e.g., App A exists in desired but not actual).
    *   Verify: Reconciler returns an `Action::Create` plan.
*   **TC-U3: MAC Address Determinism**
    *   Verify `generate_mac(uuid)` always returns the same OUI-compliant string for the same ID.

### 2. Integration Tests (Subsystem Reality Check)
*Target: `src/vmm/driver.rs`, `src/vmm/mod.rs`, `shellwego-storage`*
*Goal: Real IO calls to local binaries and kernel APIs.*

*   **TC-I1: Firecracker API Handshake**
    *   Action: Start `firecracker` binary via `Command`.
    *   Verify: Agent can successfully `GET /version` via the Unix Domain Socket.
*   **TC-I2: ZFS Dataset Lifecycle**
    *   Action: Use `ZfsManager` to create a dataset `shellwego/test-app`, snapshot it, and clone it.
    *   Verify: Filesystem is actually mounted and writable in `/var/lib/shellwego/apps/...`.
*   **TC-I3: TAP/Bridge Connectivity**
    *   Action: Use `CniNetwork` to create `swg-br0`, allocate IP `10.0.4.2`, and create `tap-test`.
    *   Verify: `ip link show` confirms interfaces exist and are "UP".
*   **TC-I4: Snapshot Persistence**
    *   Action: Create memory snapshot file via `SnapshotManager`.
    *   Verify: Metadata JSON is correctly written to disk and recoverable after a simulated process restart.

### 3. E2E Tests (The "Production Proof")
*Target: `src/main.rs`*
*Goal: One full loop of the platform's value proposition.*

*   **TC-E2E-1: The "Cold Start" Gauntlet**
    1.  **Pull:** Fetch a real Alpine OCI image.
    2.  **Build:** Convert image to ZFS rootfs dataset.
    3.  **Network:** Configure eBPF-QoS and TAP device.
    4.  **Spawn:** Fire up a microVM with 128MB RAM.
    5.  **Ping:** Reach the guest IP from the host bridge.
    6.  **Cleanup:** Stop VM, destroy TAP, destroy ZFS dataset.
    *   *Metric:* Total time must be < 10s.

*   **TC-E2E-2: Secret Injection Security**
    1.  Provision VM with "SOVEREIGN_KEY=topsecret" in `DesiredApp`.
    2.  Wait for VM boot.
    3.  Connect via `vsock` (no SSH bloat).
    4.  Verify: `env | grep SOVEREIGN_KEY` inside the VM returns the correct value.

*   **TC-E2E-3: No-Downtime Reconciliation**
    1.  Start VM with Image V1.
    2.  Update `DesiredState` to Image V2.
    3.  Verify: Reconciler triggers a "Blue-Green" or "Rolling" swap.
    4.  Verify: V1 is killed only after V2 health check passes.

---

### ðŸš€ How to Run (Hacker Style)
Add this to your `Makefile` to ensure tests run with the necessary privileges:
```makefile
test-agent-real:
	# Requires root for KVM/ZFS/Netlink
	sudo cargo test -p shellwego-agent -- --test-threads=1 --ignored
```
*(Note: Use `--ignored` or a feature flag like `#[cfg(feature = "metal_tests")]` to keep these out of standard CI and strictly for VPS validation.)*

**The result?** If these pass, you don't just have code; you have a battle-hardened cloud provider in a binary. AWS is sweating.